import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.util.*;
import java.util.zip.*;
import java.awt.event.*;
import java.io.*;
import javax.imageio.*;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import org.xml.sax.SAXException;
import fi.iki.jmtilli.javaxmlfrag.*;




/*
 * Changelog:
 * 20140308
 * - add Indium and Germanium support
 * - remove Matlab support
 *
 * 20140307
 * - remove last code included that has been written by Jouni Tiilikainen
 *
 * 20140307
 * - improve DFT: add window function and multiplier
 *
 * 20140302
 * - add globals panel with sum and product term, which are applied to
 *   simulation now
 *
 * 20131207
 * - add Niobium support
 *
 * 20131004
 * - better complex number support
 *
 * 20070601
 * - working Matlab support, finally (has been removed since)
 *
 * 20070530
 * - improved documentation
 * - changed default layer model not to fit substrate density
 * - fixed multiple critical errors in "fit" checkbox, which made the feature useless
 * - fixed a bug related to FWHM/stddev conversion
 * - inserted several comments in source code
 * - reference to the published CovGA/HGA article
 *
 * 20060830
 * - Final version by Juha-Matti Tilli <juha-matti.tilli@iki.fi>
 *   (for this summer, but the software has been improved since)
 *
 *   * Javadoc documentation can be generated by document.bat and document.sh.
 *
 *   * srcpkg.bat and srcpkg.sh create a source package which should contain
 *     all the necessary files for compiling the program from sources.
 *
 *   * binpkg.bat and binpkg.sh compile the software and create a directory
 *     structure which is suitable for distribution.
 *
 *   * the deploy directory contains some documentation in the .txt files.
 *
 *   * the license in AboutBox.java must be changed after the article is published
 *
 *
 * 20060829
 * - added resolution.txt
 *
 * 20060825
 * - NaN fix in Java simulation code
 * - fixed error reporting to octerrs.txt
 *
 * 20060824
 * - fixed Octave fitting code
 *
 * 20060822
 * - changed the default of include roughness to true
 * - added instructions to update Octave code
 *
 * 20060821
 * - fixed a race condition and audited code for other similar problems
 * - use monospaced font in about box
 * - improved roughness splitter: handle two-compound layers,
 *   warn when d would be < 0 and improve error messages,
 *   disable warning of d<0 for substrate, option to include
 *   approximate roughness (default false)
 *
 * 20060818
 * - file -> ascii export removed, use data -> linear plot -> file -> export instead
 * - file -> ascii import updated to use exports from data menu with swapped column order
 * - fixed a very minor calculation bug in DFT
 * - export layers to ascii file
 * - roughness splitting plot in data menu
 * - roughness splitting tool in layer editor
 *
 * 20060817
 * - various plots in data menu
 *
 * 20060816
 * - new EXPERIMENTAL version with updated Octave code supporting new fitting algorithms
 * - changed default min angle in DFT to 1.
 * - data menu: DFT and depth profile
 * - file -> use simulation as measurement
 *
 * 20060815
 * - Fourier transform
 *
 * 20060814
 * - FWHM indicator in automatic fit tab
 * - documentation updates
 * - convolution is quietly discarded in case of a non-uniformly spaced alpha0.
 * - delta profile export
 *
 * 20060811
 * - finished Octave convolution code
 *
 * 20060808
 * - critical angle, SLD, abs. coeff added to optical properties
 * - fixed underestimation of convolution; changed stddevs from 3 to 4
 * - added initial convolution support to Octave code & fitting code (NOT YET READY!)
 *   - update xrr4 -> xrr5, xrrGA8 -> xrrGA9
 * - changed stddev to FWHM in user interface
 *
 * 20060807
 * - convolution support (not used during fitting)
 *
 * 20060803
 * - initial convolution support (not used during fitting)
 *
 * 20060721
 * - added optical information dialog box
 * - updated README.txt
 *
 * 20060720
 * - ASCII import
 *
 * 20060719
 * - regression testing
 *
 * 20060718
 * - finished support for different wavelengths
 * - show measurement file name in title bar
 * - suggest a layer file name when saving
 *
 * 20060717
 * - ASCII export works when fitting
 * - stop button doesn't wait
 * - initial support for different wavelengths
 *
 * 20060714
 * - saves measurement path with layers
 * - realtime simulation enabled
 *
 * 20060713
 * - simulation is now done in Java code
 *
 * 20060710
 * - converted .sh files from CRLF to LF
 * - documentation improvements
 *
 * 20060621
 * - ranges and adjustment of normalization parameters for measurement import
 * - ranges and number of data points for "load empty measurement"
 * - changed software name
 * - disabled stdout debug information
 *
 * 20060620
 * - Remember directory in file chooser
 * - replaced "roo" with "rho"
 * - show correct wavelength, do not allow modification
 *
 * 20060619
 * - documentation for ascii export in deploy/
 * - fitter no longer blocks plotter
 * - fix roughness modeling in Octave code
 *
 * 20060616
 * - replaced XRRimport.m with Java code
 * - re-enabled output of octave cmds to stdout
 * - no more "double selections"
 * - write octave errors to "octerrs.txt"
 * - improved error handling
 * - removed assertions depending on user input
 *
 * 20060615
 * - deltaPerRho, betaPerRho, "From chemical compound" removed
 * - Load/save implemented
 * - Update min values after edit on manual fit tab
 * - Load empty measurement
 * - Roughness bugs fixed
 * - lookuptable2.m updated
 * - cancel button works in many places
 * - Octave path no longer asked
 * - xrr3.m modified to model roughness between upper layer and air
 * - ASCII export
 *
 * 20060614
 * - Changelog started
 * - use (max-min)/2 as val and (max+min)/2 as dval
 * - write everything sent to Octave to file "octcmds.txt"
 * - use beta in simulation
 *
 */




/** The main class implementing the main user interface code.
 *
 * <p>
 *
 * Unfortunately this complex piece of Java code is not commented well.
 * Furthermore, it uses lots of difficult Java programming tricks, such as
 * inner classes. You have to try to understand this code without comments.
 */

public class XRRApp extends JFrame implements ChooserWrapper {
    private File chooserDirectory = null;
    private FitterInterface f = null;
    private String measPath = null; /* Path of imported measurement file */
    private String hintPath = null; /* Path of measurement file from layer model */
    private final GraphData data;
    private LookupTable table;
    private static final double Cu_K_alpha = 1.5405600e-10; /* This is the default wavelength */
    private Image green, yellow;
    private Image icon16, icon32, icon48, icon64, icon128;
    private LayerStack layers;
    private JList<String> layeredList;
    private double dbMin = -70, dbMax = 0;

    private enum PlotStyle {LIN, LOG, ALPHA4, SQRT, MRCHI2};

    private Properties props = new Properties();

    private AdvancedFitOptions opts = new AdvancedFitOptions();

    /* these must point always to the same object */
    private LayerPlotter pfit;
    private LayerPlotter p;
    private LayerStack fitLayers;
    private final XRRApp xrr;

    private JComboBox<FitnessFunction> funcBox;
    private SpinnerNumberModel pModel, firstAngleModel, lastAngleModel, thresholdModel;

    public FittingErrorFunc func()
    {
        FitnessFunction func = (FitnessFunction)funcBox.getSelectedItem();
        FittingErrorFunc func2;
        double dBthreshold = (Double)thresholdModel.getNumber();
        switch (func)
        {
          case relchi2:
            func2 = new RelChi2FittingErrorFunc(Math.exp(Math.log(10)*dBthreshold/10));
            break;
          case logfitness:
            func2 = new LogFittingErrorFunc((Integer)pModel.getNumber());
            break;
          case rel:
            func2 = new RelFittingErrorFunc();
            break;
          case sqrtfitness:
            func2 = new SqrtFittingErrorFunc((Integer)pModel.getNumber());
            break;
          case chi2:
            func2 = new Chi2FittingErrorFunc();
            break;
          case relchi2transform:
            func2 = new RelChi2TransformFittingErrorFunc(Math.exp(Math.log(10)*dBthreshold/10), (Integer)pModel.getNumber());
            break;
          default:
            throw new IllegalArgumentException();
        }
        return func2;
    }
    public GraphData gd()
    {
        return data;
    }
    public GraphData croppedGd()
    {
        return data.crop((Double)firstAngleModel.getNumber(),
                         (Double)lastAngleModel.getNumber());
    }

    private boolean settingBool(String key, boolean default_value)
    {
        try {
            String val = props.getProperty(key);
            if (val == null)
            {
                return default_value;
            }
            return Boolean.parseBoolean(val);
        }
        catch (NumberFormatException ex)
        {
            return default_value;
        }
    }

    private int settingInt(String key, int default_value, int min, int max)
    {
        try {
            String val = props.getProperty(key);
            if (val == null)
            {
                return default_value;
            }
            int num = Integer.parseInt(val);
            if (num < min || num > max)
            {
                return default_value;
            }
            return num;
        }
        catch (NumberFormatException ex)
        {
            return default_value;
        }
    }

    private double settingDouble(String key, double default_value, double min, double max)
    {
        try {
            String val = props.getProperty(key);
            if (val == null)
            {
                return default_value;
            }
            double num = Double.parseDouble(val);
            if (num < min || num > max)
            {
                return default_value;
            }
            return num;
        }
        catch (NumberFormatException ex)
        {
            return default_value;
        }
    }

    private void loadLayers(File f, boolean enable_hint) throws LayerLoadException {
        try {
            FileInputStream fstr = new FileInputStream(f);
            try {
                BufferedInputStream bs = new BufferedInputStream(fstr);
                byte[] bytes = new byte[4];
                BufferedInputStream str = bs;
                LayerStack newLayers;
                bs.mark(4);
                bs.read(bytes, 0, 4);
                bs.reset();
                if (bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC&0xFF) &&
                    bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8))
                {
                  GZIPInputStream gz = new GZIPInputStream(bs);
                  str = new BufferedInputStream(gz);
                }
                else if (bytes[0] == 'P' && bytes[1] == 'K' &&
                         bytes[2] == 3 && bytes[3] == 4)
                {
                    ZipOneInputStream gz = new ZipOneInputStream(bs);
                    str = new BufferedInputStream(gz);
                }
                Map<?,?> m;
                Object add;
                Map<?,?> addm;
                str.mark(1);
                str.read(bytes, 0, 1);
                str.reset();
                if (bytes[0] == 'd')
                {
                    Object structure = Fcode.fdecode(str, true);
                    m = (Map<?,?>)structure;
                    hintPath = null;
                    if((add = m.get("additional_data")) != null) {
                        addm = (Map<?,?>)add;
                        if(enable_hint)
                            hintPath = (String)addm.get("measPath");
                    }
                    newLayers = LayerStack.structImport(m, table);
                }
                else
                {
                    DocumentFragment doc_frag =
                        DocumentFragmentHandler.parseWhole(str);
                    doc_frag.assertTag("xrrmodel");
                    newLayers = new LayerStack(doc_frag, table);
                    hintPath = null;
                    if (doc_frag.getAttrStringObject("measPath") != null &&
                        enable_hint)
                    {
                        hintPath = doc_frag.getAttrStringNotNull("measPath");
                    }
                }
                layers.deepCopyFrom(newLayers);
            }
            finally {
                fstr.close();
            }
        }
        catch(IOException ex) {
            throw new LayerLoadException("I/O error");
        }
        catch(FdecException ex) {
            throw new LayerLoadException("Invalid low-level file format");
        }
        catch(ParserConfigurationException ex) {
            throw new LayerLoadException("No XML parser found");
        }
        catch(SAXException ex) {
            throw new LayerLoadException("Invalid physical XML format");
        }
        catch(ElementNotFound ex) {
            throw new LayerLoadException(ex.getMessage());
        }
        catch(ChemicalFormulaException ex) {
            throw new LayerLoadException("Invalid chemical formula: " + ex.getMessage());
        }
        catch(ClassCastException ex) {
            throw new LayerLoadException("Invalid low-level file format");
        }
        catch(InvalidStructException ex) {
            throw new LayerLoadException("Invalid high-level file format");
        }
    }

    private void splitRoughness(int i, double stddevs, int n, boolean includeRoughness) throws SplitRoughnessException {
        try {
            Layer bottom = layers.getElementAt(i);
            Layer top;
            double stddev = bottom.getRoughness().getExpected();
            double interval = 2*stddevs*stddev;
            double dd = interval/n;
            final double zeroApprox = 1e-6;

            if(i > 0) {
                top = layers.getElementAt(i-1);
            } else {
                top = new Layer("Air", new FitValue(0,0,0),
                              new FitValue(0,0,0), new FitValue(0,0,0), new FitValue(0,0,0),
                              new ChemicalFormula("O"),new ChemicalFormula("O"),0,
                              layers.getTable(), layers.getLambda());
            }

            ChemicalFormula topCompound = null, bottomCompound = null;

            if(top.getF() < zeroApprox)
                topCompound = top.getCompound1();
            else if(top.getF() > 1-zeroApprox)
                topCompound = top.getCompound2();

            if(bottom.getF() < zeroApprox)
                bottomCompound = bottom.getCompound1();
            else if(bottom.getF() > 1-zeroApprox)
                bottomCompound = bottom.getCompound2();

            if(topCompound == null) {
                int topGCD = 0;
                Map<String,Double> topC = top.getComposition();
                for(double d: topC.values()) {
                    int m = (int)(1000*d+0.5);
                    topGCD = SMath.gcd(m, topGCD);
                }
                if(topGCD <= 0)
                    topGCD = 1;
                String topStr = "";
                for(Map.Entry<String,Double> e: new TreeMap<String,Double>(topC).entrySet()) {
                    int m = ((int)(1000*e.getValue()+0.5))/topGCD;
                    if(m > 1)
                        topStr += e.getKey() + m;
                    else if(m == 1)
                        topStr += e.getKey();
                }
                topCompound = new ChemicalFormula(topStr);
            }
            if(bottomCompound == null) {
                int bottomGCD = 0;
                Map<String,Double> bottomC = bottom.getComposition();
                for(double d: bottomC.values()) {
                    int m = (int)(1000*d+0.5);
                    bottomGCD = SMath.gcd(m, bottomGCD);
                }
                if(bottomGCD <= 0)
                    bottomGCD = 1;
                String bottomStr = "";
                for(Map.Entry<String,Double> e: new TreeMap<String,Double>(bottomC).entrySet()) {
                    int m = ((int)(1000*e.getValue()+0.5))/bottomGCD;
                    if(m > 1)
                        bottomStr += e.getKey() + m;
                    else if(m == 1)
                        bottomStr += e.getKey();
                }
                bottomCompound = new ChemicalFormula(bottomStr);
            }

            if(top.getThickness().getExpected() - interval/2 < 0 && i > 0)
                throw new SplitRoughnessException("Top layer thickness would be smaller than 0.\n"+
                                                  "You must decrease roughness or the number of standard\n"+
                                                  "deviations or increase top layer thickness");
            if(bottom.getThickness().getExpected() - interval/2 < 0 && i < layers.getSize()-1)
                throw new SplitRoughnessException("Bottom layer thickness would be smaller than 0.\n"+
                                                  "You must decrease roughness or the number of standard\n"+
                                                  "deviations or increase bottom layer thickness");

            for(int j=0; j<n; j++) {
                double p = SMath.normCdf(stddevs*(2*(j+0.5)/n-1), 0, 1);

                String name = "Interface #"+(j+1);
                FitValue d = new FitValue(dd, dd, dd);
                FitValue r;
                if(includeRoughness)
                    r = new FitValue(dd/2, dd/2, dd/2);
                else
                    r = new FitValue(0, 0, 0);
                FitValue betaF = new FitValue(0, 10, 10);
                FitValue rho = new FitValue(
                        top.getDensity().getMin() +
                        (bottom.getDensity().getMin() - top.getDensity().getMin()) * p,
                        top.getDensity().getExpected() +
                        (bottom.getDensity().getExpected() - top.getDensity().getExpected()) * p,
                        top.getDensity().getMax() +
                        (bottom.getDensity().getMax() - top.getDensity().getMax()) * p);

                Layer interf = new Layer(name, d, rho, r, betaF, topCompound,
                        bottomCompound, p, layers.getTable(), layers.getLambda());

                layers.add(interf, i+j);
            }

            top.getThickness().setValues(Math.max(top.getThickness().getMin() - interval/2, 0),
                    Math.max(top.getThickness().getExpected() - interval/2, 0),
                    Math.max(top.getThickness().getMax() - interval/2, 0));
            bottom.getThickness().setValues(Math.max(bottom.getThickness().getMin() - interval/2, 0),
                    Math.max(bottom.getThickness().getExpected() - interval/2, 0),
                    Math.max(bottom.getThickness().getMax() - interval/2, 0));
            if(includeRoughness)
                bottom.getRoughness().setValues(dd/2, dd/2, dd/2);
            else
                bottom.getRoughness().setValues(0, 0, 0);

            layeredList.removeSelectionInterval(i+n, i+n);
        }
        catch(ChemicalFormulaException ex) {
            throw new SplitRoughnessException("Suddenly the Dungeon collapses!! - You die...");
        }
        catch(ElementNotFound ex) {
            throw new SplitRoughnessException("Suddenly the Dungeon collapses!! - You die...");
        }
    }

    public XRRApp() {
        super("XRR");
        this.xrr = this;
        data = new GraphData(null, null, null, false);
    }

    private void loadMeasurement(double[] new_alpha_0, double[] new_meas) {
        data.newData(new_alpha_0, new_meas, null, false);
        p.draw();
        pfit.draw();
    }
    private void loadMeasurement(double[] alpha_0, double[] meas, ImportOptions opts) {
        double max = 1e-99;
        if (opts.divAngleByTwo)
        {
            for(int i=0; i<alpha_0.length; i++) {
                alpha_0[i] /= 2;
            }
        }
        for(int i=0; i<meas.length; i++) {
            if(alpha_0[i] >= opts.minNormal
                    && alpha_0[i] <= opts.maxNormal
                    && meas[i] > max)
                max = meas[i];
        }
        for(int i=0; i<meas.length; i++) {
            meas[i] /= max;
        }
        int bound1 = 0, bound2 = 0;
        for(int i=0; i<meas.length; i++) {
            if(alpha_0[i] >= opts.minAngle && alpha_0[i] <= opts.maxAngle) {
                alpha_0[bound1] = alpha_0[i];
                meas[bound1] = meas[i];
                bound1++;
            }
        }
        for(int i=0; i<bound1; i++) {
            if(i % opts.modulo == 0 /* && meas[i] > 0 */ ) { /* measurement points must be uniformly spaced */
                alpha_0[bound2] = alpha_0[i];
                meas[bound2] = meas[i];
                bound2++;
            }
        }
        double[] new_alpha_0, new_meas;
        new_meas = new double[bound2];
        new_alpha_0 = new double[bound2];
        System.arraycopy(meas, 0, new_meas, 0, bound2);
        System.arraycopy(alpha_0, 0, new_alpha_0, 0, bound2);
        loadMeasurement(new_alpha_0, new_meas);
    }

    private void DFT() {
        GraphData d;
        int ndata;
        int f_high, f_low;
        int t_high, t_low;
        double[] I;
        double lambda = layers.getLambda();
        double[] alpha_0, R;
        DFTOptions opts;

        d = data.simulate(layers).normalize(layers);

        if(!XRRSimul.isUniformlySpaced(d.alpha_0)) {
            JOptionPane.showMessageDialog(null, "Values of alpha_0 not uniformly spaced", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }


        assert(d.alpha_0.length == d.meas.length);
        assert(d.alpha_0.length == d.simul.length);

        ndata = d.alpha_0.length;

        double amin;
        if(d.alpha_0[ndata-1] > 1 && d.alpha_0[0] < 1)
            amin = 1;
        else
            amin = d.alpha_0[0];

        DFTOptionDialog dialog = new DFTOptionDialog(this,amin,d.alpha_0[ndata-1],1,100);
        opts = dialog.call();
        dialog.dispose();
        if(opts == null)
            return;

        alpha_0 = new double[ndata];
        R = new double[ndata];
        System.arraycopy(d.alpha_0, 0, alpha_0, 0, ndata);
        System.arraycopy(opts.useSimul ? d.simul : d.meas, 0, R, 0, ndata);

        t_low = 0;
        t_high = ndata;
        for(int i=0; i<ndata; i++) {
            if(alpha_0[i] >= opts.minAngle) {
                t_low = i;
                break;
            }
        }
        for(int i=0; i<ndata; i++) {
            if(alpha_0[i] > opts.maxAngle) {
                t_high = i;
                break;
            }
        }

        for(int i=0; i<ndata; i++) {
            double ap2 = alpha_0[i] * alpha_0[i];
            double ap4 = ap2*ap2;
            R[i] *= ap4;
            alpha_0[i] *= Math.PI/180;
        }
        // Hann window
        if (opts.useWindow)
        {
            int nactivedata = t_high - t_low;
            for(int i=t_low; i<t_high; i++)
            {
                R[i] *= (0.5*(1-Math.cos(2*Math.PI*(i-t_low)/(nactivedata-1))));
            }
        }

        /* since alpha_0[t_high] doesn't necessarily exist, we must use this trick */
        double alpha0range = (t_high-t_low)*(alpha_0[t_high-1] - alpha_0[t_low])/(t_high-t_low-1);

        f_low = (int)Math.floor(2*opts.minThickness*1e-9*alpha0range/lambda);
        f_high = (int)Math.ceil(2*opts.maxThickness*1e-9*alpha0range/lambda);

        // we don't want DC coefficient
        if(f_low == 0 && f_high > 0)
            f_low = 1;

        int mult = opts.multiplier;

        I = new double[(f_high-f_low)*mult];
        for(int i=f_low*mult; i<f_high*mult; i++) {
            double a, b;
            a = b = 0;
            for(int j=t_low; j<t_high; j++) {
                a += R[j]*Math.cos(2*Math.PI*i*j/(t_high-t_low)/mult);
                b += R[j]*Math.sin(2*Math.PI*i*j/(t_high-t_low)/mult); 
            }
            I[i-f_low*mult] = Math.sqrt(a*a + b*b);
        }





        double[] xarray, yarray;
        ArrayList<NamedArray> yarrays = new ArrayList<NamedArray>();
        xarray = new double[(f_high - f_low)*mult];
        yarray = new double[(f_high - f_low)*mult];
        yarrays.add(new NamedArray(1, yarray, ""));
        for(int i=f_low*mult; i<f_high*mult; i++) {
            xarray[i-f_low*mult] = lambda*i/2/alpha0range/mult;
            yarray[i-f_low*mult] = I[i-f_low*mult];
        }
        //xyplot = chart.getXYPlot();
        /*xyplot.getDomainAxis().setAutoRange(false);
        xyplot.getDomainAxis().setRange(0,5);*/
        /*xyplot.getRangeAxis().setAutoRange(false);
        xyplot.getRangeAxis().setRange(-70,0);*/
        //chart.setAntiAlias(false); /* this is faster */
        new ChartFrame(this,"Discrete Fourier transform", 600, 400, false,
                new DataArray(1e9, xarray), "nm", yarrays, "spectral density", 0, 0, null).setVisible(true);

    }

    private void defaultProp(String key, String value)
    {
        if (props.getProperty(key) == null)
        {
            props.setProperty(key, value);
        }
    }

    private void maybeSetIconImages(java.util.List<? extends Image> icons)
    {
        try {
            java.lang.reflect.Method m;
            m = this.getClass().getMethod("setIconImages", java.util.List.class);
            m.invoke(this, icons);
        }
        catch(Throwable t) {}
    }


    private static String getDir()
    {
        try {
            String path = XRRApp.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            File f = new File(path);
            if (!f.isDirectory())
            {
                path = f.getParent();
            }
            return path;
        }
        catch (java.net.URISyntaxException ex)
        {
            return ".";
        }
    }



    private boolean construct() {
        /* Load atomic masses and scattering factors */
        try {
            table = new SFTables(new File(getDir(), "atomic_masses.txt"),new File(getDir(), "sf"));
        }
        catch(FileFormatException ex) {
            StringWriter writer = new StringWriter();
            PrintWriter printWriter = new PrintWriter( writer );
            ex.printStackTrace( printWriter );
            printWriter.flush();
            String stackTrace = writer.toString();
            JOptionPane.showMessageDialog(null,
                "Can't load scattering factor files\n" + stackTrace,
                "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        catch(IOException ex) {
            StringWriter writer = new StringWriter();
            PrintWriter printWriter = new PrintWriter( writer );
            ex.printStackTrace( printWriter );
            printWriter.flush();
            String stackTrace = writer.toString();
            JOptionPane.showMessageDialog(null,
                "Can't load scattering factor files\n" + stackTrace,
                "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }

        /* Load properties */
        try {
            File f = new File(getDir(), "default.properties");
            if (f.exists())
            {
                FileInputStream pfin = new FileInputStream(f);
                try {
                    props.load(pfin);
                }
                finally {
                    pfin.close();
                }
            }
            defaultProp("autofit.popsize", "-10");
            defaultProp("autofit.iters", "500");
            defaultProp("autofit.firstAngle", "0.07");
            defaultProp("autofit.lastAngle", "10.0");
            defaultProp("autofit.algorithm", "0");
            defaultProp("autofit.fitnessFunc", "0");
            defaultProp("autofit.thresRelF", "-30");
            defaultProp("autofit.pNorm", "2");
            defaultProp("autofit.k_m", "0.7");
            defaultProp("autofit.k_r", "0.85");
            defaultProp("autofit.p_m", "0.5");
            defaultProp("autofit.c_r", "0.5");
            defaultProp("autofit.lambda", "1.0");
            defaultProp("autofit.reportPerf", "false");
            defaultProp("plot.dbMin", "-70");
            defaultProp("plot.dbMax", "0");
            opts.km = Double.parseDouble(props.getProperty("autofit.k_m"));
            if (opts.km <= 0 || opts.km >= 1)
            {
                throw new NumberFormatException();
            }
            opts.kr = Double.parseDouble(props.getProperty("autofit.k_r"));
            if (opts.kr <= 0 || opts.kr >= 1)
            {
                throw new NumberFormatException();
            }
            opts.pm = Double.parseDouble(props.getProperty("autofit.p_m"));
            if (opts.pm <= 0 || opts.pm >= 1)
            {
                throw new NumberFormatException();
            }
            opts.cr = Double.parseDouble(props.getProperty("autofit.c_r"));
            if (opts.cr <= 0 || opts.cr >= 1)
            {
                throw new NumberFormatException();
            }
            opts.lambda = Double.parseDouble(props.getProperty("autofit.lambda"));
            if (opts.lambda < 0 || opts.lambda > 1)
            {
                throw new NumberFormatException();
            }
            opts.reportPerf = Boolean.parseBoolean(props.getProperty("autofit.reportPerf"));
            dbMin = Double.parseDouble(props.getProperty("plot.dbMin"));
            dbMax = Double.parseDouble(props.getProperty("plot.dbMax"));
        }
        catch(NumberFormatException ex) {
            StringWriter writer = new StringWriter();
            PrintWriter printWriter = new PrintWriter( writer );
            ex.printStackTrace( printWriter );
            printWriter.flush();
            String stackTrace = writer.toString();
            JOptionPane.showMessageDialog(null,
                "Can't load properties\n" + stackTrace,
                "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        catch(IllegalArgumentException ex) {
            StringWriter writer = new StringWriter();
            PrintWriter printWriter = new PrintWriter( writer );
            ex.printStackTrace( printWriter );
            printWriter.flush();
            String stackTrace = writer.toString();
            JOptionPane.showMessageDialog(null,
                "Can't load properties\n" + stackTrace,
                "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        catch(IOException ex) {
            StringWriter writer = new StringWriter();
            PrintWriter printWriter = new PrintWriter( writer );
            ex.printStackTrace( printWriter );
            printWriter.flush();
            String stackTrace = writer.toString();
            JOptionPane.showMessageDialog(null,
                "Can't load properties\n" + stackTrace,
                "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }



        final JTabbedPane tabs = new JTabbedPane();
        JPanel layered, graph;
        final JPanel fit = new JPanel();
        JPanel wlPanel, layeredPanel;
        JPanel layerButtonPanel;
        JTextField wl1, wl2, wl3;
        JScrollPane layeredScroll;
        //JTabbedPane sliderPane = new JTabbedPane();
        JPanel sliderPanel = new JPanel();
        layers = new LayerStack(Cu_K_alpha, table);
        layeredList = new JList<String>(layers.listModel);
        final XRRApp thisFrame = this;

        //layers.listModel.addListDataListener(new ScrollbarUpdater(layers, sliderPane));
        layers.listModel.addListDataListener(new ScrollbarUpdater(this, layers, sliderPanel));

        layered = new JPanel();
        graph = new JPanel();

        layered.setLayout(new BorderLayout());
        graph.setLayout(new BorderLayout());
        fit.setLayout(new BorderLayout());



        final Runnable errTask = new Runnable() {
            public void run() {
                JOptionPane.showMessageDialog(null,
                    "There was an error with fitting.",
                    "Fitting error", JOptionPane.ERROR_MESSAGE);
            }
        };




        /* Empty measurement */
        double[] alpha_0, meas;
        alpha_0 = new double[1001];
        meas = new double[1001];
        for(int i=0; i<alpha_0.length; i++) {
            alpha_0[i] = i*3.0/1000;
            meas[i] = 1; /* avoid log(0) = -infinity */
        }
        data.newData(alpha_0, meas, null, false);
        measPath = null;


        /* ----- layer editor -------- */

        layeredPanel = new JPanel();
        layeredPanel.setLayout(new BorderLayout());

        /*
        try {
            layers.add(new Layer("Substrate", new FitValue(0,0,0),
                       new FitValue(2.26e3,2.33e3,2.4e3), new FitValue(0,0,1e-9), new FitValue(0,10,10),
                       new ChemicalFormula("Si"),new ChemicalFormula("Si"),0,
                       layers.getTable(), layers.getLambda()));
            layers.add(new Layer("Native oxide", new FitValue(0e-9,0e-9,2.5e-9),
                       new FitValue(1e3,2.1e3,3e3), new FitValue(0,0,1e-9), new FitValue(0,10,10),
                       new ChemicalFormula("Si"),new ChemicalFormula("O"),2.0/3,
                       layers.getTable(),layers.getLambda()));
            layers.add(new Layer("Thin film", new FitValue(40e-9,55e-9,70e-9),
                       new FitValue(1e3,3.4e3,4e3), new FitValue(0,0,1e-9), new FitValue(0,10,10),
                       new ChemicalFormula("Al"),new ChemicalFormula("O"),3/5.0,
                       layers.getTable(),layers.getLambda()));
        }
        catch(ChemicalFormulaException ex) {
            throw new RuntimeException("Doesn't get thrown");
        }
        catch(ElementNotFound ex) {
            JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        */

        layeredScroll = new JScrollPane(layeredList);
        layeredScroll.setPreferredSize(new Dimension(300,150));

        layerButtonPanel = new JPanel();
        layerButtonPanel.setLayout(new GridLayout(0,1));

        JButton btn = new JButton("Move up");
        btn.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int[] i2 = layeredList.getSelectedIndices();
                if(i2 == null || i2.length == 0)
                    return;
                Arrays.sort(i2);
                if(i2[i2.length-1]+1 - i2[0] != i2.length || i2[0] <= 0)
                    JOptionPane.showMessageDialog(null, "Can't move layers up", "Error", JOptionPane.ERROR_MESSAGE);
                else {
                    layers.moveUp(i2[0], i2[i2.length-1]+1);
                    layeredList.clearSelection();
                    layeredList.setSelectionInterval(i2[0]-1, i2[i2.length-1]-1);
                }
            };
        });
        layerButtonPanel.add(btn);

        JButton b = new JButton("Add...");
        b.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e) {
                Layer l;
                try {
                    l = new Layer("New layer", new FitValue(0,100e-9,500e-9),
                                new FitValue(0,5e3,10e3),
                                new FitValue(0,0,0), new FitValue(0,10,10, false),
                                new ChemicalFormula("Al"),new ChemicalFormula("O"),3/5.0,
                                layers.getTable(),layers.getLambda());
                    LayerDialog d = new LayerDialog(thisFrame);
                    if(d.call(l)) {
                        layers.add(l);
                        // work around an obscure Java bug of "double selections"
                        layeredList.clearSelection();
                        layeredList.setSelectedIndex(0);
                    }
                    d.dispose();
                }
                catch(ChemicalFormulaException ex) {
                    throw new RuntimeException("Doesn't get thrown");
                }
                catch(ElementNotFound ex) {
                    JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                }
            }
        });
        layerButtonPanel.add(b);

        btn = new JButton("Edit...");
        btn.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int i = layeredList.getSelectedIndex();
                int[] i2 = layeredList.getSelectedIndices();
                if(i < 0 || i >= layers.getSize() || i2.length != 1)
                    JOptionPane.showMessageDialog(null, "Can't edit layer", "Error", JOptionPane.ERROR_MESSAGE);
                else {
                    LayerDialog d = new LayerDialog(thisFrame);
                    if(d.call(layers.getElementAt(i)))
                        layers.invalidate(null);
                    d.dispose();
                }
            };
        });
        layerButtonPanel.add(btn);

        b = new JButton("Copy");
        b.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e) {
                int[] i2 = layeredList.getSelectedIndices();
                for(int i: i2) {
                    Layer l = layers.getElementAt(i).deepCopy(
                        new HashMap<FitValue, Integer>(),
                        new HashMap<Integer, FitValue>());
                    try {
                        layers.add(l,layers.getSize());
                    }
                    catch (Exception ex)
                    {
                        // XXX does this happen at all?
                        JOptionPane.showMessageDialog(null, "Element not found", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        layerButtonPanel.add(b);


        b = new JButton("Link params...");
        b.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e) {
                int[] i2 = layeredList.getSelectedIndices();
                if (i2.length < 2)
                {
                    JOptionPane.showMessageDialog(
                      null,
                      "Select more than two layers by holding the CTRL\n" +
                      "button down while clicking the layers on the list\n" +
                      "to use the parameter linking feature",
                      "Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                LinkDialog d = new LinkDialog(thisFrame, "Unlink parameters");
                d.call();
                if (!d.ok())
                {
                    return;
                }
                layeredList.clearSelection();
                Layer firstLayer = layers.getElementAt(i2[0]);
                for(int i: i2) {
                    Layer oldLayer = layers.getElementAt(i);
                    Layer newLayer = oldLayer.deepCopy(
                        new HashMap<FitValue, Integer>(),
                        new HashMap<Integer, FitValue>());
                    layers.remove(i);
                    if (d.d())
                    {
                        newLayer.setThicknessObject(firstLayer.getThickness());
                    }
                    else
                    {
                        newLayer.setThicknessObject(oldLayer.getThickness());
                    }
                    if (d.rho())
                    {
                        newLayer.setDensityObject(firstLayer.getDensity());
                    }
                    else
                    {
                        newLayer.setDensityObject(oldLayer.getDensity());
                    }
                    if (d.r())
                    {
                        newLayer.setRoughnessObject(firstLayer.getRoughness());
                    }
                    else
                    {
                        newLayer.setRoughnessObject(oldLayer.getRoughness());
                    }
                    if (d.betaF())
                    {
                        newLayer.setBetaFObject(firstLayer.getBetaF());
                    }
                    else
                    {
                        newLayer.setBetaFObject(oldLayer.getBetaF());
                    }
                    try {
                        layers.add(newLayer,i);
                    }
                    catch(ElementNotFound ex) {
                        JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        layerButtonPanel.add(b);

        b = new JButton("Unlink params...");
        b.addActionListener(new ActionListener(){
            public void actionPerformed(ActionEvent e) {
                int[] i2 = layeredList.getSelectedIndices();
                LinkDialog d = new LinkDialog(thisFrame, "Unlink parameters");
                d.call();
                if (!d.ok())
                {
                    return;
                }
                layeredList.clearSelection();
                for(int i: i2) {
                    Layer oldLayer = layers.getElementAt(i);
                    Layer newLayer = oldLayer.deepCopy(
                        new HashMap<FitValue, Integer>(),
                        new HashMap<Integer, FitValue>());
                    if (!d.d())
                    {
                        newLayer.setThicknessObject(oldLayer.getThickness());
                    }
                    if (!d.rho())
                    {
                        newLayer.setDensityObject(oldLayer.getDensity());
                    }
                    if (!d.r())
                    {
                        newLayer.setRoughnessObject(oldLayer.getRoughness());
                    }
                    if (!d.betaF())
                    {
                        newLayer.setBetaFObject(oldLayer.getBetaF());
                    }
                    layers.remove(i);
                    try {
                        layers.add(newLayer,i);
                    }
                    catch(ElementNotFound ex) {
                        JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        layerButtonPanel.add(b);

        btn = new JButton("Optics...");
        btn.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int i = layeredList.getSelectedIndex();
                int[] i2 = layeredList.getSelectedIndices();
                if(i < 0 || i >= layers.getSize() || i2.length != 1)
                    JOptionPane.showMessageDialog(null, "Can't display optical information", "Error", JOptionPane.ERROR_MESSAGE);
                else {
                    InfoDialog d = new InfoDialog(thisFrame);
                    d.call(layers.getElementAt(i));
                    d.dispose();
                }
            };
        });
        layerButtonPanel.add(btn);

        btn = new JButton("Split roughness...");
        btn.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int i = layeredList.getSelectedIndex();
                int[] i2 = layeredList.getSelectedIndices();
                if(i < 0 || i >= layers.getSize() || i2.length != 1)
                    JOptionPane.showMessageDialog(null, "You must select exactly one layer to use this tool", "Error", JOptionPane.ERROR_MESSAGE);
                else {
                    if (layers.getElementAt(i).getBetaF().getExpected() < 3)
                    {
                        if (JOptionPane.showConfirmDialog(
                                null,
                                "The layer has betaF < 3 and it will not be " +
                                "taken into account by the split roughness " +
                                "tool.\n\n" +
                                "Do you still want to continue?",
                                "Question", JOptionPane.YES_NO_OPTION,
                                JOptionPane.QUESTION_MESSAGE)
                          != JOptionPane.YES_OPTION)
                        {
                          return;
                        }
                    }
                    try {
                        SplitRoughnessDialog dialog = new SplitRoughnessDialog(thisFrame);
                        SplitRoughnessOpts opts = dialog.call();
                        dialog.dispose();
                        if(opts != null)
                            splitRoughness(i, opts.stddevs, opts.n, opts.includeRoughness);
                    }
                    catch(SplitRoughnessException ex) {
                        JOptionPane.showMessageDialog(null, ex.toString(), "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            };
        });
        layerButtonPanel.add(btn);

        btn = new JButton("Delete");
        btn.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int[] i2 = layeredList.getSelectedIndices();
                for(int k=i2.length-1; k>=0; k--) {
                    int i = i2[k];
                    layers.remove(i);
                    if(i < layers.getSize())
                        layeredList.setSelectedIndex(i);
                    else if(i >= 1)
                        layeredList.setSelectedIndex(i-1);
                }
                if(i2.length > 0 && layers.getSize() > 0) {
                    if(i2[0] < layers.getSize())
                      layeredList.setSelectedIndex(i2[0]);
                    else
                      layeredList.setSelectedIndex(i2[0]-1);
                }
            };
        });
        layerButtonPanel.add(btn);

        btn = new JButton("Move down");
        btn.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                int[] i2 = layeredList.getSelectedIndices();
                if(i2 == null || i2.length == 0)
                    return;
                Arrays.sort(i2);
                if(i2[i2.length-1]+1 - i2[0] != i2.length || i2[i2.length-1]+1 >= layers.getSize())
                    JOptionPane.showMessageDialog(null, "Can't move layers down", "Error", JOptionPane.ERROR_MESSAGE);
                else {
                    layers.moveDown(i2[0], i2[i2.length-1]+1);
                    layeredList.clearSelection();
                    layeredList.setSelectionInterval(i2[0]+1, i2[i2.length-1]+1);
                }
            };
        });
        layerButtonPanel.add(btn);

        layeredPanel.add(layeredScroll,BorderLayout.CENTER);
        layeredPanel.add(layerButtonPanel,BorderLayout.EAST);
        layered.add(layeredPanel,BorderLayout.CENTER);



        /* -------------- wavelength selector --------------- */

        wlPanel = new JPanel();
        wlPanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        wlPanel.add(new JLabel("Wavelength"));
        final JLabel editWlLabel = new JLabel("");
        final JButton editWlButton = new JButton("Edit...");
        //wlPanel.add(new JLabel("nm"));
        wlPanel.add(editWlLabel);
        wlPanel.add(editWlButton);
        layered.add(wlPanel,BorderLayout.NORTH);

        editWlButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                WavelengthDialog dialog = new WavelengthDialog(thisFrame);
                Double lambda2 = dialog.call(layers.getLambda());
                dialog.dispose();
                if(lambda2 != null) {
                    try {
                        layers.changeLambda(lambda2);
                    }
                    catch(ElementNotFound ex) {
                        JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        layers.listModel.addListDataListener(new ListDataListener() {
            private void updateWl() {
                editWlLabel.setText(String.format(Locale.US,"%.6f",layers.getLambda()*1e9)+" nm");
            }
            public void intervalAdded(ListDataEvent e) {
                updateWl();
            }
            public void intervalRemoved(ListDataEvent e) {
                updateWl();
            }
            public void contentsChanged(ListDataEvent e) {
                updateWl();
            }
        });


        JPanel northWlPanel = new JPanel();
        northWlPanel.setLayout(new BorderLayout());
        final JPlotArea light = new JPlotArea();
        light.setPreferredSize(new Dimension(32,32));
        light.setMinimumSize(new Dimension(32,32));
        northWlPanel.add(light,BorderLayout.EAST);
        graph.add(northWlPanel,BorderLayout.NORTH);

        northWlPanel = new JPanel();
        northWlPanel.setLayout(new BorderLayout());
        wlPanel = new JPanel();
        wlPanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        wlPanel.add(new JLabel("Wavelength"));
        final JLabel fitWlLabel = new JLabel("");
        wlPanel.add(fitWlLabel);
        wlPanel.add(new JLabel(" FWHM"));
        final JLabel fitConvLabel = new JLabel("");
        wlPanel.add(fitConvLabel);
        wlPanel.add(new JLabel(" norm"));
        final JLabel fitNormLabel = new JLabel("");
        wlPanel.add(fitNormLabel);
        wlPanel.add(new JLabel(" beam"));
        final JLabel fitBeamLabel = new JLabel("");
        wlPanel.add(fitBeamLabel);
        wlPanel.add(new JLabel(" sum"));
        final JLabel fitSumLabel = new JLabel("");
        wlPanel.add(fitSumLabel);
        wlPanel.add(new JLabel(" offset"));
        final JLabel fitOffsetLabel = new JLabel("");
        wlPanel.add(fitOffsetLabel);

        final JPlotArea fitPlotLight = new JPlotArea();
        final JPlotArea fitLight = new JPlotArea();
        JPanel lightPanel = new JPanel();
        fitPlotLight.setPreferredSize(new Dimension(32,32));
        fitPlotLight.setMinimumSize(new Dimension(32,32));
        fitLight.setPreferredSize(new Dimension(32,32));
        fitLight.setMinimumSize(new Dimension(32,32));
        lightPanel.add(fitPlotLight);
        lightPanel.add(fitLight);
        try {
            green = ImageIO.read(fitLight.getClass().getClassLoader().getResourceAsStream("green.png"));
            yellow = ImageIO.read(fitLight.getClass().getClassLoader().getResourceAsStream("yellow.png"));
            icon16 = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream("micronovaxrr16.png"));
            icon32 = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream("micronovaxrr32.png"));
            icon48 = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream("micronovaxrr48.png"));
            icon64 = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream("micronovaxrr64.png"));
            icon128 = ImageIO.read(this.getClass().getClassLoader().getResourceAsStream("micronovaxrr128.png"));
        }
        catch(IOException ex) {
            JOptionPane.showMessageDialog(null, "can't read png files", "Error", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        fitLight.newImage(green);
        northWlPanel.add(wlPanel,BorderLayout.CENTER);
        northWlPanel.add(lightPanel,BorderLayout.EAST);
        fit.add(northWlPanel,BorderLayout.NORTH);

        maybeSetIconImages(Arrays.asList(new Image[]{icon16, icon32, icon48, icon64, icon128}));



        /* -------------------- measurement loading -------------------- */

        /* these must be created before automatic fit creation code */

        final JMenuItem fileLoadMeas = new JMenuItem("Load measurement...");
        final JMenuItem fileLoadEmpty = new JMenuItem("Load empty measurement...");
        final JMenuItem fileLoadAscii = new JMenuItem("Load ASCII export...");
        final JMenuItem fileSwap = new JMenuItem("Use simulation as measurement");
        final JMenuItem fileLayerExport = new JMenuItem("Export layers to text file...");


        /* ------------------- automatic fit -------------------- */
        //final JPlotArea fitPlotArea = new JPlotArea();
        final XChartArea fitPlotArea = new XChartArea();
        fitLayers = new LayerStack(layers.getLambda(), layers.getTable());

        pfit = new LayerPlotter(fitPlotArea, fitPlotLight, fitLayers, data, green, yellow, dbMin, dbMax);

        fitLayers.addLayerModelListener(new LayerModelAdapter() {
            public void modelPropertyChanged(EventObject ev) {
                final double FWHM_SCALE = 2*Math.sqrt(2*Math.log(2));

                fitWlLabel.setText(String.format(Locale.US,"%.6f",fitLayers.getLambda()*1e9)+" nm");
                fitConvLabel.setText(String.format(Locale.US,"%.6f",fitLayers.getStdDev().getExpected()*180/Math.PI*FWHM_SCALE)+"\u00B0");
                fitNormLabel.setText(String.format(Locale.US,"%.3f",fitLayers.getProd().getExpected())+" dB "+(fitLayers.getProd().getEnabled()?"(fit)":"(no)"));
                fitBeamLabel.setText(String.format(Locale.US,"%.3f",fitLayers.getBeam().getExpected())+" "+(fitLayers.getBeam().getEnabled()?"(fit)":"(no)"));
                fitSumLabel.setText(String.format(Locale.US,"%.3f",fitLayers.getSum().getExpected())+" dB " +(fitLayers.getSum().getEnabled()?"(fit)":"(no)"));
                fitOffsetLabel.setText(String.format(Locale.US,"%.3f",fitLayers.getOffset().getExpected())+"\u00B0 "+(fitLayers.getOffset().getEnabled()?"(fit)":"(no)"));
            }
        });
        //fitLayers.invalidate(this);

        GridBagConstraints c = new GridBagConstraints();
        JPanel fitSouth = new JPanel();
        JList<String> fitList = new JList<String>(fitLayers.listModel);
        JScrollPane fitListPane = new JScrollPane(fitList);
        fitListPane.setPreferredSize(new Dimension(400,190));

        fitPlotArea.setPreferredSize(new Dimension(600,400));
        fitPlotArea.setPreferredSize(new Dimension(600,400));
        JPanel fitPlotWrapper = new JPanel();
        fitPlotWrapper.setLayout(new BorderLayout());
        fitPlotWrapper.add(fitPlotArea, BorderLayout.CENTER);
        //fitPlotWrapper.add(new JCenterImageArea("meassimullegend.png", 2),
        //                   BorderLayout.SOUTH);
        fit.add(fitPlotWrapper,BorderLayout.CENTER);
        JPanel plotControls = new JPanel();
        plotControls.setLayout(new GridBagLayout());
        final JButton exportButton = new JButton("Export");
        final JButton importButton = new JButton("Import");
        importButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                fitLayers.deepCopyFrom(layers);
            }
        });

        final JButton startFitButton = new JButton("Start");
        final JButton stopFitButton = new JButton("Stop");
        final JButton advancedButton = new JButton("Opts");
        final SpinnerNumberModel popSizeModel = new SpinnerNumberModel(settingInt("autofit.popsize", -10, -200, 2000),-200,2000,1);
        final SpinnerNumberModel iterationsModel = new SpinnerNumberModel(settingInt("autofit.iters", 500, 1, 2000),1,2000,1);
        pModel = new SpinnerNumberModel(settingInt("autofit.pNorm", 2, 1, 10),1,10,1);
        final SpinnerNumberModel autostopModel = new SpinnerNumberModel(settingInt("autofit.autostopFigures", 6, 2, 10),2,10,1);
        firstAngleModel = new SpinnerNumberModel(settingDouble("autofit.firstAngle", 0.07, 0, 10),0,10,0.01);
        lastAngleModel = new SpinnerNumberModel(settingDouble("autofit.lastAngle", 10, 0, 10),0,10,0.01);
        thresholdModel = new SpinnerNumberModel(settingDouble("autofit.thresRelF", -30, -500, 500),-500,500,0.1);
        final JComboBox<Algorithm> algoBox = new JComboBox<Algorithm>(Algorithm.values());
        final JCheckBox autostop = new JCheckBox("automatic fit stop with figures");
        algoBox.setSelectedItem(Algorithm.values()[settingInt("autofit.algorithm", 0, 0, Algorithm.values().length)]);
        funcBox = new JComboBox<FitnessFunction>(FitnessFunction.values());
        funcBox.setSelectedItem(FitnessFunction.values()[settingInt("autofit.fitnessFunc", 0, 0, FitnessFunction.values().length)]);
        /*
        final JCheckBox nonlinBox = new JCheckBox("Nonlinear fitness space estimation");
        nonlinBox.setSelected(true);
        */

        startFitButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                try {
                    LayerTask endTask = new LayerTask() {
                        public void run(LayerStack s, String msg) {
                            f = null;
                            startFitButton.setEnabled(true);
                            stopFitButton.setEnabled(false);
                            tabs.setTitleAt(2, "Automatic fit");
                            importButton.setEnabled(true);
                            //exportButton.setEnabled(true);
                            fileLoadMeas.setEnabled(true);
                            fileLoadAscii.setEnabled(true);
                            fileLoadEmpty.setEnabled(true);
                            fileSwap.setEnabled(true);
                            pfit.setAdditionalTitle("");
                            if (msg != null && !msg.equals(""))
                            {
                                JOptionPane.showMessageDialog(null,
                                    msg,
                                    "Fitting performance",
                                    JOptionPane.INFORMATION_MESSAGE);
                            }
                        }
                    };
                    final Runnable errTask2 = new Runnable() {
                        public void run() {
                            f = null;
                            startFitButton.setEnabled(true);
                            stopFitButton.setEnabled(false);
                            tabs.setTitleAt(2, "Automatic fit");
                            importButton.setEnabled(true);
                            //exportButton.setEnabled(true);
                            fileLoadMeas.setEnabled(true);
                            fileLoadAscii.setEnabled(true);
                            fileLoadEmpty.setEnabled(true);
                            fileSwap.setEnabled(true);
                            pfit.setAdditionalTitle("");
                            pfit.draw();
                            errTask.run();
                        }
                    };
                    LayerTask plotTask = new LayerTask() {
                        public void run(LayerStack s, String msg) {
                            pfit.setAdditionalTitle(msg);
                            fitLayers.deepCopyFrom(s);
                        }
                    };
                    Algorithm algo = (Algorithm)algoBox.getSelectedItem();
                    try {
                        f = new JavaFitter(xrr, fitLight, data, endTask, plotTask, errTask2, fitLayers,
                                           (Integer)popSizeModel.getNumber(), (Integer)iterationsModel.getNumber(),
                                           (Double)firstAngleModel.getNumber(), (Double)lastAngleModel.getNumber(),
                                           green, yellow, (Algorithm)algoBox.getSelectedItem(), autostop.isSelected(), (Integer)autostopModel.getNumber(), opts);//, nonlinBox.isSelected());
                    }
                    catch (FittingNotStartedException ex)
                    {
                        JOptionPane.showMessageDialog(null,
                            "There was an error with fitting.",
                            "Fitting error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                    startFitButton.setEnabled(false);
                    stopFitButton.setEnabled(true);
                    tabs.setTitleAt(2, "Automatic fit (*)");
                    stopFitButton.addActionListener(new ActionListener() {
                        public void actionPerformed(ActionEvent ev) {
                            f.closeWithoutWaiting();
                            stopFitButton.setEnabled(false);
                        }
                    });
                    importButton.setEnabled(false);
                    //exportButton.setEnabled(false);
                    fileLoadMeas.setEnabled(false); /* */
                    fileLoadAscii.setEnabled(false); /* */
                    fileLoadEmpty.setEnabled(false); /* */
                    fileSwap.setEnabled(false);
                }
                catch(Exception ex) {
                    errTask.run();
                }
            }
        });
        advancedButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                AdvancedFitDialog diag = new AdvancedFitDialog(thisFrame);
                diag.call(opts);
            }
        });
        exportButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                layers.deepCopyFrom(fitLayers);
            }
        });
        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridBagLayout());
        c.ipadx = c.ipady = 1;
        c.anchor = GridBagConstraints.NORTH;
        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(1,1,1,1);
        c.gridwidth = 1;
        buttonPanel.add(importButton);
        //c.gridwidth = GridBagConstraints.REMAINDER;
        buttonPanel.add(startFitButton);
        c.gridwidth = 1;
        buttonPanel.add(exportButton);
        c.gridwidth = 1;
        stopFitButton.setEnabled(false);
        buttonPanel.add(stopFitButton);

        c.gridwidth = GridBagConstraints.REMAINDER;
        stopFitButton.setEnabled(false);
        buttonPanel.add(advancedButton);

        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(buttonPanel, c);


        c.gridwidth = 1;
        plotControls.add(new JLabel("Population size"),c);
        //c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JSpinner(popSizeModel),c);

        c.gridwidth = 1;
        plotControls.add(new JLabel("Iterations"),c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JSpinner(iterationsModel),c);

        c.gridwidth = 1;
        plotControls.add(new JLabel("First angle"),c);
        //c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JSpinner(firstAngleModel),c);

        c.gridwidth = 1;
        plotControls.add(new JLabel("Last angle"),c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JSpinner(lastAngleModel),c);

        c.gridwidth = 1;
        //c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JLabel("Algorithm"),c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(algoBox,c);

        //c.gridwidth = 1;
        //plotControls.add(new JLabel("Nonlinear"),c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        //plotControls.add(nonlinBox,c);
        
        c.gridwidth = 1;
        //c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JLabel("Fitness function"),c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(funcBox,c);

        c.gridwidth = 1;
        plotControls.add(new JLabel("Thres. rel.f. (dB)"),c);
        c.gridwidth = 1;
        plotControls.add(new JSpinner(thresholdModel),c);

        c.gridwidth = 1;
        plotControls.add(new JLabel("p-norm"),c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JSpinner(pModel),c);

        c.gridwidth = 3;
        autostop.setSelected(settingBool("autofit.autostop", true));
        plotControls.add(autostop, c);
        c.gridwidth = GridBagConstraints.REMAINDER;
        plotControls.add(new JSpinner(autostopModel),c);

        c.weighty = 1;
        plotControls.add(new JPanel(),c);
        /* fit.add(plotControls,BorderLayout.SOUTH); */
        fitSouth.setLayout(new BorderLayout());
        fitSouth.add(plotControls,BorderLayout.EAST);
        fitSouth.add(fitListPane,BorderLayout.CENTER);
        fit.add(fitSouth,BorderLayout.SOUTH);



        /* ------------------ manual fit -------------- */

        //final JPlotArea plotarea = new JPlotArea();
        final XChartArea plotarea = new XChartArea();

        p = new LayerPlotter(plotarea, light, layers, data, green, yellow, dbMin, dbMax);

        p.setDbRange(dbMin, dbMax);
        pfit.setDbRange(dbMin, dbMax);

        plotarea.setPreferredSize(new Dimension(600,400));
        //graph.add(plotarea,BorderLayout.CENTER);
        JPanel plotWrapper = new JPanel();
        plotWrapper.setLayout(new BorderLayout());
        plotWrapper.add(plotarea, BorderLayout.CENTER);
        //plotWrapper.add(new JCenterImageArea("meassimullegend.png", 2),
        //                   BorderLayout.SOUTH);
        graph.add(plotWrapper,BorderLayout.CENTER);
        graph.add(sliderPanel,BorderLayout.SOUTH);

        //layers.invalidate(this);



        /* add tabs */

        tabs.addTab("Layer editor", null, layered, "Layer editor");
        tabs.addTab("Manual fit", null, graph, "Manual fitting");
        tabs.addTab("Automatic fit", null, fit, "Automatic fitting");



        /* --------- menu bars -------------- */

        final ActionListener exitAction = new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                p.close();
                pfit.close();
                if(f != null)
                    f.close();
                thisFrame.dispose();
            }
        };

        this.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                exitAction.actionPerformed(null);
            }
        });


        JMenuBar menuBar = new JMenuBar();
        JMenu fileMenu = new JMenu("File");
        menuBar.add(fileMenu);

        JMenu dataMenu = new JMenu("Data");
        menuBar.add(dataMenu);

        JMenu helpMenu = new JMenu("Help");
        menuBar.add(helpMenu);

        fileLoadMeas.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                JFileChooser chooser = new JFileChooser();
                if(chooserDirectory != null)
                    chooser.setCurrentDirectory(chooserDirectory);
                if(hintPath != null && new File(hintPath).exists())
                    chooser.setSelectedFile(new File(hintPath));
                if(chooser.showOpenDialog(thisFrame) == JFileChooser.APPROVE_OPTION) {
                    chooserDirectory = chooser.getCurrentDirectory();
                    try {
                        XRRImport.XRRData importdat;
                        FileInputStream filein = new FileInputStream(chooser.getSelectedFile());
                        try {
                            importdat = XRRImport.XRRImport(filein);
                        }
                        finally {
                            filein.close();
                        }

                        for (int i = 1; i < importdat.arrays.length; i++)
                        {
                            assert(importdat.arrays[i].length == importdat.arrays[0].length);
                            assert(importdat.arrays[i].length > 0);
                        }

                        ImportDialog dialog = new ImportDialog(thisFrame,importdat.arrays[0].length,
                            importdat.arrays[0][0], importdat.arrays[0][importdat.arrays[0].length-1], importdat.valid, importdat.isTwoTheta);
                        ImportOptions opts = dialog.call();
                        dialog.dispose();
                        if(opts == null)
                            return;

                        loadMeasurement(importdat.arrays[0], importdat.arrays[opts.meascol-1], opts);

                        measPath = chooser.getSelectedFile().getAbsolutePath();
                        String fname = chooser.getName(chooser.getSelectedFile());
                        hintPath = null;

                        setTitle("XRR ("+fname+")");
                    }
                    catch(XRRImportException ex) {
                        JOptionPane.showMessageDialog(null, "Invalid file format", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(IOException ex) {
                        JOptionPane.showMessageDialog(null, "I/O error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        fileMenu.add(fileLoadMeas);

        fileLoadEmpty.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                double[] alpha_0, meas;
                LoadEmptyDialog dialog = new LoadEmptyDialog(thisFrame);
                DataOptions opts = dialog.call();
                dialog.dispose();
                if(opts == null)
                    return;

                alpha_0 = new double[opts.ndata];
                meas = new double[opts.ndata];
                for(int i=0; i<alpha_0.length; i++) {
                    alpha_0[i] = i*(opts.max-opts.min)/(opts.ndata-1) + opts.min;
                    meas[i] = 1; /* avoid log(0) = -infinity */
                }

                data.newData(alpha_0, meas, null, false);
                measPath = null;
                p.draw();
                pfit.draw();
                setTitle("XRR");
            }
        });
        fileMenu.add(fileLoadEmpty);

        fileSwap.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                GraphData d;
                d = data.simulate(layers).normalize(layers);
                loadMeasurement(d.alpha_0, d.simul);
                measPath = null;
                setTitle("XRR");
            }
        });

        fileMenu.add(fileSwap);
        fileMenu.addSeparator();


        JMenuItem fileLoadLayers = new JMenuItem("Load layers...");
        fileLoadLayers.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                JFileChooser chooser = new JFileChooser();
                if(chooserDirectory != null)
                    chooser.setCurrentDirectory(chooserDirectory);
                if(chooser.showOpenDialog(thisFrame) == JFileChooser.APPROVE_OPTION) {
                    chooserDirectory = chooser.getCurrentDirectory();
                    try {
                        loadLayers(chooser.getSelectedFile(),true);
                        if (tabs.getSelectedComponent() == fit)
                        {
                            JOptionPane.showMessageDialog(
                                null,
                                "The model was loaded to the manual fit " +
                                "tab.\n\nYou're on the automatic fit tab.\n\n" +
                                "To import " +
                                "the model to the automatic fit tab, press " +
                                "\"Import\"",
                                "Info", JOptionPane.INFORMATION_MESSAGE);
                        }
                    }
                    catch(LayerLoadException ex) {
                        JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    /*
                    try {
                        FileInputStream fstr = new FileInputStream(chooser.getSelectedFile());
                        BufferedInputStream bs = new BufferedInputStream(fstr);
                        Map<?,?> m;
                        Object add;
                        Map<?,?> addm;
                        Object structure = Fcode.fdecode(bs, true);
                        m = (Map<?,?>)structure;
                        hintPath = null;
                        if((add = m.get("additional_data")) != null) {
                            addm = (Map<?,?>)add;
                            hintPath = (String)addm.get("measPath");
                        }
                        LayerStack newLayers = LayerStack.structImport(m, table);
                        layers.deepCopyFrom(newLayers);
                    }
                    catch(IOException ex) {
                        JOptionPane.showMessageDialog(null, "I/O error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(FdecException ex) {
                        JOptionPane.showMessageDialog(null, "Invalid low-level file format", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(ElementNotFound ex) {
                        JOptionPane.showMessageDialog(null, ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(ClassCastException ex) {
                        JOptionPane.showMessageDialog(null, "Invalid low-level file format", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(InvalidStructException ex) {
                        JOptionPane.showMessageDialog(null, "Invalid high-level file format", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    */
                }
            }
        });
        fileMenu.add(fileLoadLayers);

        JMenuItem fileSaveLayers = new JMenuItem("Save layers...");
        fileSaveLayers.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                JFileChooser chooser = new JFileChooser();
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be saved is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to save?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                if(chooserDirectory != null)
                    chooser.setCurrentDirectory(chooserDirectory);
                if(measPath != null) {
                    File layersFile = new File(measPath+".layers");
                    File parentDir = layersFile.getParentFile();
                    if(parentDir != null && parentDir.isDirectory())
                        chooser.setSelectedFile(new File(measPath+".layers"));
                }
                if(chooser.showSaveDialog(thisFrame) == JFileChooser.APPROVE_OPTION) {
                    chooserDirectory = chooser.getCurrentDirectory();
                    try {
                        Map<String,Object> additional_data = new HashMap<String,Object>();
                        File f = chooser.getSelectedFile();
                        String fs = f.getPath();
                        FileOutputStream fstr = new FileOutputStream(f);
                        OutputStream str = fstr;
                        if (fs.endsWith(".gz"))
                        {
                            str = new GZIPOutputStream(fstr);
                        }
                        else if (fs.endsWith(".zip"))
                        {
                            String plain = fs.substring(0, fs.length()-4);
                            str = new ZipOneOutputStream(fstr, plain);
                        }
                        try {
                            if (fs.endsWith(".xml") ||
                                fs.endsWith(".xml.gz") ||
                                fs.endsWith(".xml.zip") ||
                                fs.endsWith(".xmllayers") ||
                                fs.endsWith(".xmllayers.gz") ||
                                fs.endsWith(".xmllayers.zip") ||
                                fs.endsWith(".xml.layers") ||
                                fs.endsWith(".xml.layers.gz") ||
                                fs.endsWith(".xml.layers.zip"))
                            {
                                DocumentFragment doc = new DocumentFragment("xrrmodel");
                                doc.setThisRow(layers);
                                if (measPath != null)
                                {
                                    doc.setAttrString("measPath", measPath);
                                }
                                doc.unparse(XMLDocumentType.WHOLE, str);
                            }
                            else
                            {
                                additional_data.put("measPath",measPath == null ? "" : measPath);
                                Fcode.fencode(layers.structExport(additional_data), str);
                            }
                        }
                        finally {
                            str.flush();
                            if (str != fstr)
                            {
                                str.close();
                            }
                            fstr.close();
                        }
                    }
                    catch(IOException ex) {
                        JOptionPane.showMessageDialog(null, "I/O error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(FencException ex) {
                        JOptionPane.showMessageDialog(null, "Internal error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(ParserConfigurationException ex) {
                        JOptionPane.showMessageDialog(null, "Internal error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(TransformerConfigurationException ex) {
                        JOptionPane.showMessageDialog(null, "Internal error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    catch(TransformerException ex) {
                        JOptionPane.showMessageDialog(null, "Internal error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        fileMenu.add(fileSaveLayers);

        fileLayerExport.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                JFileChooser chooser = new JFileChooser();
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be exported is the " +
                            "one on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to export?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                if(chooserDirectory != null)
                    chooser.setCurrentDirectory(chooserDirectory);
                if(chooser.showSaveDialog(thisFrame) == JFileChooser.APPROVE_OPTION) {
                    chooserDirectory = chooser.getCurrentDirectory();
                    try {
                        OutputStream fstr = new FileOutputStream(chooser.getSelectedFile());
                        try {
                            Writer rw = new OutputStreamWriter(fstr);
                            BufferedWriter bw = new BufferedWriter(rw);
                            PrintWriter w = new PrintWriter(bw);
                            w.print(layers);
                            if(w.checkError())
                              throw new IOException();
                        }
                        finally {
                            fstr.close();
                        }
                    }
                    catch(IOException ex) {
                        JOptionPane.showMessageDialog(null, "I/O error", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                }
            }
        });
        fileMenu.add(fileLayerExport);


        fileMenu.addSeparator();


        JMenuItem fileExit = new JMenuItem("Exit");
        fileMenu.add(fileExit);
        fileExit.addActionListener(exitAction);

        JMenuItem dataRange = new JMenuItem("Plot range...");
        dataRange.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                DbRangeDialog dbrd = new DbRangeDialog(thisFrame);
                if(dbrd.call(dbMin, dbMax)) {
                    dbMin = dbrd.getDbMin();
                    dbMax = dbrd.getDbMax();
                    p.setDbRange(dbMin, dbMax);
                    pfit.setDbRange(dbMin, dbMax);
                }
                dbrd.dispose();
            }
        });
        dataMenu.add(dataRange);
        dataMenu.addSeparator();

        JMenuItem dataDFT = new JMenuItem("Discrete Fourier transform...");
        dataDFT.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.DFT();
            }
        });
        dataMenu.add(dataDFT);
        dataMenu.addSeparator();

        JMenuItem dataProfile = new JMenuItem("Depth profile (delta)...");
        dataProfile.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.profile(XRRSimul.XRRProperty.DELTA);
            }
        });
        dataMenu.add(dataProfile);
        dataProfile = new JMenuItem("Depth profile (beta)...");
        dataProfile.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.profile(XRRSimul.XRRProperty.BETA);
            }
        });
        dataMenu.add(dataProfile);
        dataProfile = new JMenuItem("Depth profile (density)...");
        dataProfile.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.profile(XRRSimul.XRRProperty.DENSITY);
            }
        });
        dataMenu.add(dataProfile);

        dataMenu.addSeparator();

        JMenuItem dataPlot = new JMenuItem("Linear plot");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.plot(PlotStyle.LIN);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("Logarithmic plot");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.plot(PlotStyle.LOG);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("R*alpha^4-plot");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.plot(PlotStyle.ALPHA4);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("Sqrt-plot");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.plot(PlotStyle.SQRT);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("MRchi2-plot");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.plot(PlotStyle.MRCHI2);
            }
        });
        dataMenu.add(dataPlot);

        dataMenu.addSeparator();

        dataPlot = new JMenuItem("Linear plot (split roughness)");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.accuratePlot(PlotStyle.LIN);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("Logarithmic plot (split roughness)");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.accuratePlot(PlotStyle.LOG);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("R*alpha^4-plot (split roughness)");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.accuratePlot(PlotStyle.ALPHA4);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("Sqrt-plot (split roughness)");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.accuratePlot(PlotStyle.SQRT);
            }
        });
        dataMenu.add(dataPlot);
        dataPlot = new JMenuItem("MRchi2-plot (split roughness)");
        dataPlot.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                if (    tabs.getSelectedComponent() == fit
                    &&  fitLayers != null
                    && !fitLayers.equals(layers))
                {
                    if (JOptionPane.showConfirmDialog(
                            null,
                            "The model that's going to be plotted is the one " +
                            "on the manual fit tab and that's different " +
                            "from the model on the automatic fit tab.\n\n" +
                            "You're on the automatic fit tab. To export " +
                            "the model to the manual fit tab, press " +
                            "\"Export\".\n\nDo you still want to plot?",
                            "Question", JOptionPane.YES_NO_OPTION,
                            JOptionPane.QUESTION_MESSAGE)
                      != JOptionPane.YES_OPTION)
                    {
                      return;
                    }
                }
                thisFrame.accuratePlot(PlotStyle.MRCHI2);
            }
        });
        dataMenu.add(dataPlot);
        dataMenu.addSeparator();
        JMenuItem dataNoise = new JMenuItem("Add noise...");
        dataNoise.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                PhotonLevelDialog dialog = new PhotonLevelDialog(thisFrame);
                Double level;
                if((level = dialog.call()) != null) {
                    GraphData data2 = data.addNoise(Math.exp(Math.log(10)*level/10));
                    data.newData(data2.alpha_0, data2.meas, data2.simul, data2.logformat);

                    /* ... */
                    p.draw();
                    pfit.draw();
                }
                dialog.dispose();
            }
        });
        dataMenu.add(dataNoise);

        JMenuItem helpAbout = new JMenuItem("About...");
        helpAbout.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent ev) {
                AboutDialog dialog = new AboutDialog(thisFrame);
                dialog.call();
                dialog.dispose();
            }
        });
        helpMenu.add(helpAbout);


        String defaultMeasName = "default.xrdml.gz";
        try {
            String[] names = {
                "default.xrdml.gz",
                "default.xrdml.zip",
                "default.xrdml",
                "default.x00.gz",
                "default.x00.zip",
                "default.x00",
                "default.brml",
                "default.udf.gz",
                "default.udf.zip",
                "default.udf",
                "default.rd.gz",
                "default.rd.zip",
                "default.rd",
                "default.sd.gz",
                "default.sd.zip",
                "default.sd",
                "default.raw.gz",
                "default.raw.zip",
                "default.raw",
                "default.uxd.gz",
                "default.uxd.zip",
                "default.uxd",
                "default.ras.gz",
                "default.ras.zip",
                "default.ras",
                "default.dat.gz",
                "default.dat.zip",
                "default.dat",
                "default.asc.gz",
                "default.asc.zip",
                "default.asc",
                "default.rig.gz",
                "default.rig.zip",
                "default.rig",
                "default.txt.gz",
                "default.txt.zip",
                "default.txt",
                "default.xy.gz",
                "default.xy.zip",
                "default.xy",
            };
            String path = getDir();
            for (String name: names)
            {
                File f = new File(path, name);
                if (f.exists())
                {
                    XRRImport.XRRData importdat;
                    defaultMeasName = f.getName();
                    FileInputStream filein = new FileInputStream(f);
                    try {
                        importdat = XRRImport.XRRImport(filein);
                    }
                    finally {
                        filein.close();
                    }

                    for (int i = 1; i < importdat.arrays.length; i++)
                    {
                        assert(importdat.arrays[i].length == importdat.arrays[0].length);
                        assert(importdat.arrays[i].length > 0);
                    }
                    boolean[] valid = importdat.valid;
                    int col;
                    if (valid.length == 3 && valid[0] && valid[1] && valid[2])
                    {
                        col = 3;
                    }
                    else
                    {
                        col = 2;
                    }
                    ImportOptions opts = new ImportOptions(1, 0, 90, 0.07, 90, col, importdat.isTwoTheta);
                    loadMeasurement(importdat.arrays[0], importdat.arrays[opts.meascol-1], opts);
                    measPath = f.getAbsolutePath();
                    String fname = f.getName();
                    hintPath = null;

                    setTitle("XRR ("+fname+")");
                    break;
                }
            }
        }
        catch(XRRImportException ex) {
            JOptionPane.showMessageDialog(null, "There was an error in the file " + defaultMeasName + ":\n"+ex.getMessage(), "Error in " + defaultMeasName, JOptionPane.ERROR_MESSAGE);
        }
        catch(IOException ex) {
            JOptionPane.showMessageDialog(null, "There was an error in reading the file " + defaultMeasName + ":\n"+ex.getMessage(), "Error in reading " + defaultMeasName, JOptionPane.ERROR_MESSAGE);
        }


        String defaultLayersName = "default.xmllayers";
        try {
            String[] names = {
                "default.xmllayers.gz",
                "default.xmllayers.zip",
                "default.xmllayers",
                "default.xml.layers.gz",
                "default.xml.layers.zip",
                "default.xml.layers",
                "default.layers.xml.gz",
                "default.layers.xml.zip",
                "default.layers.xml",
                "default.xml.gz",
                "default.xml.zip",
                "default.xml",
                "default.layers.gz",
                "default.layers.zip",
                "default.layers"
            };
            String path = getDir();
            for (String name: names)
            {
                File f = new File(path, name);
                if (f.exists())
                {
                    defaultLayersName = name;
                    loadLayers(new File(path, name),false);
                    break;
                }
            }
        }
        catch(LayerLoadException ex) {
            JOptionPane.showMessageDialog(null, "There was an error in the file " + defaultLayersName + ":\n"+ex.getMessage(), "Error in " + defaultLayersName, JOptionPane.ERROR_MESSAGE);
        }


        this.getContentPane().add(tabs);
        this.setJMenuBar(menuBar);
        this.pack();

        return true;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                XRRApp frame = new XRRApp();
                if(frame.construct())
                    frame.setVisible(true);
            }
        });
    }

    private void plot(PlotStyle style) {
        GraphData d;
        double[] meas, simul;
        double ymin = 0, ymax = 0;
        String ytitle;

        d = data.simulate(layers).normalize(layers);
        meas = new double[d.meas.length];
        simul = new double[d.simul.length];
        System.arraycopy(d.meas, 0, meas, 0, meas.length);
        System.arraycopy(d.simul, 0, simul, 0, simul.length);

        double dBthreshold = (Double)thresholdModel.getNumber();
        RelChi2TransformFittingErrorFunc func = new RelChi2TransformFittingErrorFunc(Math.exp(Math.log(10)*dBthreshold/10), (Integer)pModel.getNumber());
        switch(style) {
            case LOG:
                for(int i=0; i<meas.length; i++) {
                    meas[i] = 10*Math.log(meas[i])/Math.log(10);
                    simul[i] = 10*Math.log(simul[i])/Math.log(10);
                    if(meas[i] < ymin && !Double.isInfinite(meas[i]))
                        ymin = meas[i];
                    if(simul[i] < ymin && !Double.isInfinite(simul[i]))
                        ymin = simul[i];
                    if(meas[i] > ymax && !Double.isInfinite(meas[i]))
                        ymax = meas[i];
                    if(simul[i] > ymax && !Double.isInfinite(simul[i]))
                        ymax = simul[i];
                    if(Double.isInfinite(meas[i]))
                        meas[i] = -100;
                    if(Double.isInfinite(simul[i]))
                        simul[i] = -100;
                }
                ytitle = "dB";
                break;
            case SQRT:
                for(int i=0; i<meas.length; i++) {
                    meas[i] = Math.sqrt(meas[i]);
                    simul[i] = Math.sqrt(simul[i]);
                }
                ytitle = "sqrt(reflectivity)";
                break;
            case ALPHA4:
                for(int i=0; i<meas.length; i++) {
                    double a0 = d.alpha_0[i];
                    double a0_2 = a0*a0;
                    double a0_4 = a0_2*a0_2;
                    meas[i] = meas[i]*a0_4;
                    simul[i] = simul[i]*a0_4;
                }
                ytitle = "reflectivity*alpha0^4 (degrees^4)";
                break;
            case MRCHI2:
                for(int i=0; i<meas.length; i++) {
                    meas[i] = func.transform(meas[i]);
                    simul[i] = func.transform(simul[i]);
                }
                ytitle = "MRchi2(reflectivity)";
                break;
            default:
                ytitle = "reflectivity";
                break;
        }

        ArrayList<NamedArray> yarrays = new ArrayList<NamedArray>();
        yarrays.add(new NamedArray(1, simul, "Simulation"));
        yarrays.add(new NamedArray(1, meas, "Measurement"));

        //xyplot = chart.getXYPlot();
        /*xyplot.getDomainAxis().setAutoRange(false);
        xyplot.getDomainAxis().setRange(0,5);*/
        /*xyplot.getRangeAxis().setAutoRange(false);
        xyplot.getRangeAxis().setRange(-70,0);*/
        //chart.setAntiAlias(false); /* this is faster */
        new ChartFrame(this,"Reflectivity plot", 600, 400, true,
                new DataArray(1, d.alpha_0), "degrees", yarrays, ytitle, ymin, ymax, "meassimullegend.png").setVisible(true);

    }


    private void profile(XRRSimul.XRRProperty property) {
        double[] range;
        DataOptions opts;
        boolean small_beta = false;
        for (int i = 0; i < layers.getSize(); i++)
        {
            Layer l = layers.getElementAt(i);
            if (l.getBetaF().getExpected() < 3)
            {
                small_beta = true;
                break;
            }
        }

        if (small_beta)
        {
            if (JOptionPane.showConfirmDialog(
                    null,
                    "On of the layers has betaF < 3 and it has not been " +
                    "well-tested with depth profile.\n\n" +
                    "Do you still want to plot depth profile?",
                    "Question", JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE)
              != JOptionPane.YES_OPTION)
            {
              return;
            }
        }

        range = XRRSimul.depths(2, layers);

        DepthProfileDialog dialog = new DepthProfileDialog(this, range[0]*1e9, range[1]*1e9);
        opts = dialog.call();
        dialog.dispose();

        if(opts == null)
            return;

        double[] ds, delta, delta2;

        ds = XRRSimul.depths2(opts.ndata, opts.min/1e9, opts.max/1e9);
        delta = XRRSimul.depthProfile(ds, layers, false, property);
        delta2 = XRRSimul.depthProfile(ds, layers, true, property);

        assert(ds.length == delta.length);
        assert(ds.length == delta2.length);



        ArrayList<NamedArray> yarrays = new ArrayList<NamedArray>();
        yarrays.add(new NamedArray(1, delta, "Smooth profile"));
        yarrays.add(new NamedArray(1, delta2, "Sharp profile"));

        //xyplot = chart.getXYPlot();
        /*xyplot.getDomainAxis().setAutoRange(false);
        xyplot.getDomainAxis().setRange(0,5);*/
        /*xyplot.getRangeAxis().setAutoRange(false);
        xyplot.getRangeAxis().setRange(-70,0);*/
        //chart.setAntiAlias(false); /* this is faster */
        new ChartFrame(this,"Depth profile", 600, 400, true,
                new DataArray(1e9, ds), "nm", yarrays, property.title, 0, 0, "smoothsharplegend.png").setVisible(true);

    }



    private void accuratePlot(PlotStyle style) {
        double[] range;
        DataOptions opts;
        String ytitle;
        boolean small_beta = false;
        for (int i = 0; i < layers.getSize(); i++)
        {
            Layer l = layers.getElementAt(i);
            if (l.getBetaF().getExpected() < 3)
            {
                small_beta = true;
                break;
            }
        }

        if (small_beta)
        {
            if (JOptionPane.showConfirmDialog(
                    null,
                    "On of the layers has betaF < 3 and it will not be " +
                    "taken into account by the split roughness plot.\n\n" +
                    "Do you still want to plot?",
                    "Question", JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE)
              != JOptionPane.YES_OPTION)
            {
              return;
            }
        }


        range = XRRSimul.depths(2, layers);

        DepthProfileDialog dialog = new DepthProfileDialog(this, range[0]*1e9, range[1]*1e9);
        opts = dialog.call();
        dialog.dispose();

        if(opts == null)
            return;

        double[] ds, delta1, beta1, delta, beta, betaFeranchuk, alpha0rad, r, d;
        double lambda, stddevrad, beam;

        ds = XRRSimul.depths2(opts.ndata, opts.min/1e9, opts.max/1e9);
        delta1 = XRRSimul.depthProfile(ds, layers, false, XRRSimul.XRRProperty.DELTA);
        beta1 = XRRSimul.depthProfile(ds, layers, false, XRRSimul.XRRProperty.BETA);
        delta = new double[delta1.length+1];
        beta = new double[delta1.length+1];
        betaFeranchuk = new double[delta1.length+1];
        r = new double[delta1.length+1];
        d = new double[delta1.length+1];
        d[0] = r[0] = delta[0] = beta[0] = 0; /* air */
        betaFeranchuk[0] = 10;
        for(int i=1; i<r.length; i++) {
            delta[i] = delta1[i-1];
            beta[i] = beta1[i-1];
            r[i] = 0;
            betaFeranchuk[i] = 10;
            d[i] = (opts.max/1e9 - opts.min/1e9)/(opts.ndata - 1);
        }
        alpha0rad = new double[data.alpha_0.length];
        for(int i=0; i<alpha0rad.length; i++)
            alpha0rad[i] = data.alpha_0[i]*Math.PI/180;
        lambda = layers.getLambda();
        stddevrad = layers.getStdDev().getExpected();
        beam = layers.getBeam().getExpected();
        double offset = layers.getOffset().getExpected()*Math.PI/180;

        double[] splitR, NCR;
        GraphData simulData;
        splitR = XRRSimul.rawSimulateComplexBufferArray(alpha0rad, delta, beta, betaFeranchuk, d, r, lambda, stddevrad, beam, offset);

        simulData = data.simulate(layers).normalize(layers);
        NCR = new double[simulData.simul.length];
        for(int i=0; i<simulData.simul.length; i++)
            NCR[i] = simulData.simul[i];

        assert(NCR.length == alpha0rad.length);
        assert(splitR.length == alpha0rad.length);

        double ymin = 0, ymax = 0;
        double dBthreshold = (Double)thresholdModel.getNumber();
        RelChi2TransformFittingErrorFunc func = new RelChi2TransformFittingErrorFunc(Math.exp(Math.log(10)*dBthreshold/10), (Integer)pModel.getNumber());

        switch(style) {
            case LOG:
                for(int i=0; i<splitR.length; i++) {
                    splitR[i] = 10*Math.log(splitR[i])/Math.log(10);
                    NCR[i] = 10*Math.log(NCR[i])/Math.log(10);
                    if(splitR[i] < ymin && !Double.isInfinite(splitR[i]))
                        ymin = splitR[i];
                    if(NCR[i] < ymin && !Double.isInfinite(NCR[i]))
                        ymin = NCR[i];
                    if(splitR[i] > ymax && !Double.isInfinite(splitR[i]))
                        ymax = splitR[i];
                    if(NCR[i] > ymax && !Double.isInfinite(NCR[i]))
                        ymax = NCR[i];
                    if(Double.isInfinite(splitR[i]))
                        splitR[i] = -100;
                    if(Double.isInfinite(NCR[i]))
                        NCR[i] = -100;
                }
                ytitle = "dB";
                break;
            case SQRT:
                for(int i=0; i<splitR.length; i++) {
                    splitR[i] = Math.sqrt(splitR[i]);
                    NCR[i] = Math.sqrt(NCR[i]);
                }
                ytitle = "sqrt(reflectivity)";
                break;
            case ALPHA4:
                for(int i=0; i<splitR.length; i++) {
                    double a0 = data.alpha_0[i];
                    double a0_2 = a0*a0;
                    double a0_4 = a0_2*a0_2;
                    splitR[i] = splitR[i]*a0_4;
                    NCR[i] = NCR[i]*a0_4;
                }
                ytitle = "reflectivity*alpha0^4 (degrees^4)";
                break;
            case MRCHI2:
                for(int i=0; i<splitR.length; i++) {
                    splitR[i] = func.transform(splitR[i]);
                    NCR[i] = func.transform(NCR[i]);
                }
                ytitle = "MRchi2(reflectivity)";
                break;
            default:
                ytitle = "reflectivity";
                break;
        }

        ArrayList<NamedArray> yarrays = new ArrayList<NamedArray>();
        yarrays.add(new NamedArray(1, NCR, "Nevot-Croce roughness"));
        yarrays.add(new NamedArray(1, splitR, "Split roughness"));

        new ChartFrame(this,"Reflectivity", 600, 400, true,
                new DataArray(1, data.alpha_0), "degrees", yarrays, ytitle,
                0, 0, "splitnevotlegend.png").setVisible(true);

    }



    public File showFileDialog(JFrame owner, boolean save) {
        JFileChooser chooser = new JFileChooser();
        int retval;
        if(chooserDirectory != null)
            chooser.setCurrentDirectory(chooserDirectory);

        if(save)
            retval = chooser.showSaveDialog(owner);
        else
            retval = chooser.showOpenDialog(owner);

        if(retval == JFileChooser.APPROVE_OPTION) {
            chooserDirectory = chooser.getCurrentDirectory();
            return chooser.getSelectedFile();
        }
        else
            return null;
    }
}
